#!/usr/bin/perl


use strict;
sub verbose_message($);
sub subscribe_to_signals;

# Check if required Perl modules are installed and import them
Rdiffopke->import_required_modules;

my $rdiffopke = Rdiffopke->new;
subscribe_to_signals $rdiffopke;
    
$rdiffopke->get_params_and_input;
$rdiffopke->init_repository;
$rdiffopke->check_source;
$rdiffopke->proceed;
$rdiffopke->terminate;

# We should never get there
exit -1;

###############################
#
# Miscelleaneous functions
#
###############################

sub subscribe_to_signals {
    my $rdiffopke = shift;
    $SIG{INT}  = sub { $rdiffopke->quit_error(10); };
    $SIG{TERM} = sub { $rdiffopke->quit_error(11); };
}

sub verbose_message($) {
    my $message = shift;
    print localtime(time) . "   $message\n";
}

###############################
#
# Class:  Rdiffopke
#
###############################

package Rdiffopke;

sub import_required_modules {
    my @modules = qw(  Getopt::Std DBI DBD::SQLite   );

    # File::Path::Hashed Path::Class Path::Class::File Path::Class::Dir
    my @messages = ();

    foreach (@modules) {
        eval "use $_";
        push @messages, $_ if ($@);
    }

    if (@messages) {
        print STDERR
          "Some Perl modules are missing for rdiffopke to run. Missing:\n";
        print STDERR "$_\n" foreach (@messages);
        exit 1;
    }
}

sub new {
    return bless {};
}

sub get_params_and_input {
    my $self    = shift;
    my $getopts = {};

    getopts( 'vu:p:d:s:ic:x', $getopts ) or quit_error(8);

    $self->{verbose}       = 1 if ( $getopts->{v} );
    $self->{no_encryption} = $getopts->{x};
    $self->{source}        = $getopts->{s};
    $self->{repo_dir}      = $getopts->{d};

    unless ( $self->{source} && $self->{repo_dir} ) {
 $DB::single = 1;
               $self->quit_error(8);
    }

}

sub init_repository {
    my $self = shift;

    $self->{repository} = Rdiffopke::Repository->new(
        dir                 => $self->{repo_dir},
        verbose             => $self->{verbose},
        no_encryption       => $self->{no_encryption},
        upgrade_metadata_to => $self->need_metadata_schema_version
    );
    if ( !$self->{repository}->init ) {
        $self->quit_error( $self->{repository}->error_code );
    }

}

sub version {
    my $self = shift;
    return 0.1;
}

sub need_metadata_schema_version {
    my $self = shift;
    return 1;
}

sub repository {
    my $self = shift;
    return $self->{repository};
}

sub terminate {
    my ( $self, $code, $message ) = @_;
     
    $self->repository->set_message("${code}- $message") if ( defined ($code) && defined ($self->repository));

    $self->repository->close if (  defined ($self->repository));
    exit 0;
}

sub quit_error {
    my ( $self, $error_code, @messages ) = @_;

    my %errors = (
        1 => "Some Perl modules are missing for rdiffopke to run.\n",
        2 =>
          "'$self->{repo_dir}' is neither writable nor browseable -> aborting",
        3 =>
"'$self->{repo_dir}' has files inside but is missing the public key file '$self->userkey->filename' -> aborting",
        4 =>
"You have requested no encryption but there is a public key file '$self->userkey->filename' -> aborting",
        5 =>
"There is a metadata file '$self->metadata->filename' but the public key file '$self->userkey->filename' is missing ! Set to 'no encryption' if you never used it there -> aborting",
        6 =>
"Metadata file '$self->metadata->filename' seems to be corrupted. It should be a SQLite database -> aborting",
        7 =>
"An error occurred while initializing metadata '$self->metadata->filename' file -> aborting",
        8 =>
"Usage: $0 [-v] [-u <username>] [-p <password>] [-x] [-c <credentials_file>] [-i] -s <source> -d <local_destination_dir>

-i read credentials from stdin

-l list increments

-x disable encryption
delete increments

-? size opke key
-? size blowfish key
-? size read buffer
-? nb threads (default no threads)
thorough verify


il faudrait une option pour tout verifier

Note:
Source only support local directory or ftp:// at this time",
        9 =>
"Could not read metadata version from metadata file '$self->metadata->filename' -> aborting",
        10 => "Killed (SIGTERM)",
        11 => "Aborted by user (SIGINT)",
        12 => "The local rdiff '$self->{repo_dir}' is not a directory",
        13 => "An error occurred during user key creation",
        14 => "An error occurred while upgrading metadata schema",

    );

    print STDERR localtime(time) . "   $errors{$error_code}\n";
    foreach (@messages) {
        print STDERR localtime(time) . "   $_\n";
    }

    $self->terminate( $error_code, $errors{$error_code} );
}

###############################
#
# Class:  Rdiffopke::Metadata
#
###############################

package Rdiffopke::Metadata;

sub new {
	my $class = shift;
    my %params = @_;
    $DB::single = 1;
    return unless ( defined $params{dir} );
    return bless {
        dir        => $params{dir},
        error_code => 0,
        verbose    => $params{verbose},  filename    => "$params{dir}/metadata"
    };

}

sub init {
    my $self   = shift;
    my %params = @_;

    if ( -e $self->filename ) {

        unless ( $self->connect ) {
            return 0;    # $self->error_code is already set
        }

        eval {
            local $self->_dbh->{RaiseError} = 1;
            local $self->_dbh->{PrintError} = 0;
            $DB::single = 1;
            $self->{schema_version} = $self->_dbh->selectrow_array(
                'select value from options where name = "metadata_version";');
        };
        if ($@) {
            $self->error_code(9);
            return 0;
        }
        unless ( defined( $self->{schema_version} )
            && $self->{schema_version} > 0 )
        {
            $self->error_code(9);
            return 0;
        }

        $self->_upgrade_schema( $params{upgrade_metadata_to} )
          if ( $self->schema_version < $params{upgrade_metadata_to} );

    }
    else {
        unless ( $self->connect ) {
            return 0;    # $self->error_code is already set
        }
        $self->{schema_version} = 0;
    }

    $self->_upgrade_schema( $params{upgrade_metadata_to} );

    local $self->_dbh->{PrintError} = 0;

    $self->_dbh->do("PRAGMA foreign_keys = ON");
    $self->_dbh->do("PRAGMA default_synchronous = OFF");

    if ( $params{upgrade_to} && $self->schema_version < $params{upgrade_to} ) {
        unless ( $self->_upgrade_schema_to( $params{upgrade_to} ) ) {
            return 0;    # $self->error_code is already set
        }

    }
        
     return 1;        # Returns true
}

sub _connect {
    my $self = shift;

    my $dbh = DBI->connect( "dbi:SQLite:dbname=${self->filename}", "", "" );
    unless ( defined $dbh ) {
        $self->error_code(6);
        return 0;
    }

    $self->{dbh} = $dbh;
    return 1;    # Returns true
}

sub _disconnect {
    my $self = shift;

    $self->_dbh->close;
    return 1;    # Returns true
}

sub schema_version {
    my $self = shift;
    return $self->{schema_version};
}

sub _upgrade_schema {
    my $self       = shift;
    my $upgrade_to = shift;

    my %db_schema_versions = (
        1 => [
'create table diffs (diff integer primary key not null, date_begin datetime not null, date_end datetime not null, message text);',
'create table options (name text primary key not null, value text);',
'create table files (file_id integer primary key autoincrement not null, diff integer not null, path_id integer not null, localfile_id integer, retrieval_date datetime not null, owner text, "group" text, mode text, mdate datetime not null, type text not null, size integer not null, target text );',
'create table paths (path_id integer primary key autoincrement not null, path text not null);',
'create table localfiles (localfile_id integer primary key autoincrement not null, path text not null, size integer not null, key_id integer);',
'create table keys ( key_id integer primary key autoincrement not null, key blob not null);',
        ],
    );

    verbose_message("Metadata schema needs upgrade, do not interrupt...")
      if ( $self->{verbose} );

    for ( my $i = $self->schema_version + 1 ; $i <= $upgrade_to ; $i++ ) {

        eval {
            local $self->_dbh->{RaiseError} = 1;
            local $self->_dbh->{PrintError} = 0;
            $self->_dbh->begin_work;
            foreach ( @{ $db_schema_versions{$i} } ) {
                $DB::single = 1;
                $self->_dbh->do($_);
            }
            $self->_dbh->do(
                "update options set value = $i where name = 'metadata_version';"
            );
        };
        if ($@) {
            $self->_dbh->rollback;
            $self->error_code(14);
            return 0;
        }
        else {
            $self->_dbh->commit;
            $self->{schema_version} = $i;

        }
    }

    verbose_message("Finished upgrade of metadata schema")
      if ( $self->{verbose} );

    return 1;    # Returns true
}

sub _dbh {
    my $self = shift;
    return $self->{dbh};
}


sub set_message {
    my ( $self, $message ) = @_;
    
     $DB::single = 1;
               $self->_dbh->do(
               "update diffs set message = $message where diff = ${self->diff};"            ) if ($self->diff);


}


sub diff {
  my $self = shift;
    return $self->{diff};
}

###############################
#
# Class:  Rdiffopke::Repository
#
###############################

package Rdiffopke::Repository;

sub new {
		my $class = shift;
	$DB::single = 1;
    my %params = @_;
    return unless ( defined $params{dir} );
    return bless {
        dir                 => $params{dir},
        error_code          => 0,
        verbose             => $params{verbose},
        no_encryption       => $params{no_encryption},
        upgrade_metadata_to => $params{upgrade_metadata_to},
    };

}

sub diff {
  my $self = shift;
    return $self->{diff};
}

sub error_code {
    my $self = shift;
    return $self->{error_code};
}

sub init {
    my $self = shift;

    if ( -e $self->{dir} && !-d $self->{dir} ) {
        $self->error(12);
        return 0;

    }
    else {
        verbose_message("Creating local reverse-diffs directory '$self->{dir}'")
          if ( $self->{verbose} );
        mkdir $self->{dir};
    }

    unless ( -d $self->{dir}
        && -x $self->{dir}
        && -w $self->{dir} )
    {
        $self->error_code(2);
        return 0;
    }

    my $userkey = Rdiffopke::Userkey->new(
        dir     => $self->dir,
        verbose => $self->verbose
    );
    my $metadata = Rdiffopke::Metadata->new(
        dir     => $self->dir,
        verbose => $self->verbose
    );

    $DB::single=1;
  #  if (! $userkey->exists && !$self->no_encryption && </Users/alex/tmp/rdiffopke/*> ) {
    if (! $userkey->exists && !$self->no_encryption && (<${self->dir}/*>) ) {
    $self->error_code(3);
    return 0;
    }

    if ( !$userkey->init ) {
        $self->error_code( $userkey->error_code );
        return 0;
    }

    if ( $self->no_encryption && -e $userkey->exists ) {
        $self->error_code(4);
        return 0;
    }

    if (   $self->metadata->exists
        && !$userkey->exists
        && !$self->no_encryption )
    {
        $self->error_code(5);
        return 0;
    }

    unless ( $self->no_encryption ) {
        unless ( $userkey->init ) {
            $self->error_code(13);
            return 0;
        }
    }

    unless ( $metadata->init( upgrade_to => $self->{upgrade_metadata_to} ) ) {
        $self->error_code( $metadata->error_code );
        return 0;
    }

    $self->{metadata} = $metadata;
    $self->{userkey}  = $userkey;
    
   
    
    return 1;    # Returns true;
}


sub dir {
    my $self = shift;
    return $self->{dir};
}

sub verbose {
    my $self = shift;
    return $self->{verbose};
}

sub metadata {
    my $self = shift;
    return $self->{metadata};
}

sub close {
    my $self = shift;
    $self->metadata->close;
}

sub filename {
      my $self = shift;
    return $self->{filename};
}
 
sub schema_version {
    my $self = shift;
    return $self->metadata->schema_version;
}


sub set_message {
    my ( $self, $message ) = @_;
     $DB::single = 1;
    $self->metadata->set_message($message) if ($self->metadata);
}


###############################
#
# Class:  Rdiffopke::Userkey
#
###############################

package Rdiffopke::Userkey;

sub new {
	my $class = shift;
    my %params = @_;
    return unless ( defined $params{dir} );
    return bless {
        dir        => $params{dir},
        error_code => 0,
        verbose    => $params{verbose},
        filename    => "$params{dir}/pubkey",
    };

}

sub exists {
    my $self = shift;
    ( -e $self->filename ) ? 1 : 0;
}

sub filename {
    my $self = shift;
    return $self->{filename};
}
