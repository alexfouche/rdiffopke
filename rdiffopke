#!/usr/bin/perl

use strict;
sub verbose_message($);
sub subscribe_to_signals;

package Rdiffopke;
use base qw(Class::Accessor::Fast );
Rdiffopke->mk_accessors(
    qw( repository no_encryption source rdiff_dir verbose ));
Rdiffopke->mk_ro_accessors(qw( version need_metadata_schema_version ));

package Rdiffopke::Metadata;

use base qw(Class::Accessor::Fast );
Rdiffopke::Metadata->mk_accessors qw( error_code );
Rdiffopke::Metadata->mk_ro_accessors
  qw( diff _dbh schema_version _verbose _filename);

package Rdiffopke::Filesource;

use base qw(Class::Accessor::Fast );
Rdiffopke::Filesource->mk_accessors qw( error_code );
Rdiffopke::Filesource->mk_ro_accessors qw(  _verbose );

package Rdiffopke::Filesource::_Localdir;

use base qw( Rdiffopke::Filesource Class::Accessor::Fast );
Rdiffopke::Filesource::_Localdir->mk_ro_accessors qw(  _dir);

package Rdiffopke::Repository;

use base qw(Class::Accessor::Fast );
Rdiffopke::Repository->mk_accessors qw( error_code );
Rdiffopke::Repository->mk_ro_accessors
  qw( diff _dir _verbose _no_encryption metadata userkey);

package Rdiffopke::Userkey;

use base qw(Class::Accessor::Fast );
Rdiffopke::Userkey->mk_ro_accessors qw( _filename );

package main;

# Check if required Perl modules are installed and import them
Rdiffopke->import_required_modules;

my $rdiffopke = Rdiffopke->new;
subscribe_to_signals $rdiffopke;

$rdiffopke->get_params_and_input;
$rdiffopke->init_repository;

#$rdiffopke->check_source;
#$rdiffopke->proceed;
$rdiffopke->terminate;

# We should never get there
exit -1;

###############################
#
# Miscelleaneous functions
#
###############################

sub subscribe_to_signals {
    my $rdiffopke = shift;
    $SIG{INT}  = sub { $rdiffopke->quit_error(10); };
    $SIG{TERM} = sub { $rdiffopke->quit_error(11); };
}

sub verbose_message($) {
    my $message = shift;
    print localtime(time) . "   $message\n";
}

###############################
#
# Class:  Rdiffopke
#
###############################

package Rdiffopke;

sub import_required_modules {
    my @modules =
      qw( Class::Accessor Class::Accessor::Fast Getopt::Std DBI DBD::SQLite   );

    # File::Path::Hashed Path::Class Path::Class::File Path::Class::Dir
    my @messages = ();

    foreach (@modules) {
        eval "use $_";
        push @messages, $_ if ($@);
    }

    if (@messages) {
        print STDERR
          "Some Perl modules are missing for rdiffopke to run. Missing:\n";
        print STDERR "$_\n" foreach (@messages);
        exit 1;
    }
}

sub new {
    return bless {
        version                      => 0.1,
        need_metadata_schema_version => 1,
        no_encryption                => 0
    };
}

sub get_params_and_input {
    my $self    = shift;
    my $getopts = {};

    getopts( 'vu:p:d:s:ic:x', $getopts ) or quit_error(8);

    $self->verbose(1) if ( $getopts->{v} );
    $self->no_encryption( $getopts->{x} );
    $self->source( $getopts->{s} );
    $self->rdiff_dir( $getopts->{d} );

    unless ( $self->source && $self->rdiff_dir ) {
        $DB::single = 1;
        $self->quit_error(8);
    }

}

sub init_repository {
    my $self = shift;

    $self->repository(
        Rdiffopke::Repository->new(
            dir                 => $self->rdiff_dir,
            verbose             => $self->verbose,
            no_encryption       => $self->no_encryption,
            upgrade_metadata_to => $self->need_metadata_schema_version
        )
    );
    if ( !$self->repository->init ) {
        $self->quit_error( $self->repository->error_code );
    }

}

sub terminate {
    my ( $self, $code, $message ) = @_;

    $self->repository->set_message("${code}- $message")
      if ( defined($code) && defined( $self->repository ) );

    $self->repository->close if ( defined $self->repository );
    exit 0;
}

sub quit_error {
    my ( $self, $error_code, @messages ) = @_;

    my %errors = (
        1 => "Some Perl modules are missing for rdiffopke to run.\n",
        2 =>
          "'$self->rdiff_dir' is neither writable nor browseable -> aborting",
        3 =>
"'$self->rdiff_dir' has files inside but is missing the public key file -> aborting",

#        3 =>
# "'$self->rdiff_dir' has files inside but is missing the public key file '${self->repository->userkey->filename}' -> aborting",
        4 =>
"You have requested no encryption but there is a public key file -> aborting",

#        4 =>
# "You have requested no encryption but there is a public key file '${self->repository->userkey->filename}' -> aborting",
        5 =>
"There is a metadata file  but the public key file is missing ! Set to 'no encryption' if you never used it there -> aborting",

#        5 =>
#"There is a metadata file '$self->repository->metadata->filename' but the public key file '${self->repository->userkey->filename}' is missing ! Set to 'no encryption' if you never used it there -> aborting",
        6 =>
"Metadata file seems to be corrupted. It should #be a SQLite database -> aborting",

#        6 =>
# "Metadata file '${self->repository->metadata->filename}' seems to be corrupted. It should #be a SQLite database -> aborting",
        7 => "An error occurred while initializing metadata file -> aborting",

#        7 =>
#"An error occurred while initializing metadata '${self->repository->metadata->filename}' file -> aborting",
        8 =>
"Usage: $0 [-v] [-u <username>] [-p <password>] [-x] [-c <credentials_file>] [-i] -s <source> -d <local_destination_dir>

-i read credentials from stdin

-l list increments

-x disable encryption
delete increments

-? size opke key
-? size blowfish key
-? size read buffer
-? nb threads (default no threads)
thorough verify


il faudrait une option pour tout verifier

Note:
Source only support local directory or ftp:// at this time",
        9 => "Could not read metadata version from metadata file -> aborting",

#        9 =>
# "Could not read metadata version from metadata file '$self->repository->metadata->filename' -> aborting",
        10 => "Killed (SIGTERM)",
        11 => "Aborted by user (SIGINT)",
        12 => "The local rdiff '$self->rdiff_dir' is not a directory",
        13 => "An error occurred during user key creation",
        14 => "An error occurred while upgrading metadata schema",
        15 =>
"The parameter given to tell_which_files_needed() is not a Rdiffopke::Filelist instance",

    );

    $DB::single = 1;
    print STDERR localtime(time) . "   $errors{$error_code}\n";
    foreach (@messages) {
        print STDERR localtime(time) . "   $_\n";
    }

    $self->terminate( $error_code, $errors{$error_code} );
}

###############################
#
# Class:  Rdiffopke::Metadata
#
###############################

package Rdiffopke::Metadata;

sub new {
    my $class  = shift;
    my %params = @_;
    $DB::single = 1;
    return unless ( defined $params{dir} );
    return bless {
        error_code => 0,
        _verbose   => $params{verbose},
        _filename  => "$params{dir}/metadata"
    };

}

sub init {
    my $self   = shift;
    my %params = @_;

    if ( -e $self->_filename ) {

        unless ( $self->_connect ) {
            return 0;    # $self->error_code is already set
        }

        eval {
            local $self->_dbh->{RaiseError} = 1;
            local $self->_dbh->{PrintError} = 0;
            $DB::single = 1;
            $self->schema_version(
                $self->_dbh->selectrow_array(
                    'select value from options where name = "metadata_version";'
                )
            );
        };
        if ($@) {
            $self->error_code(9);
            return 0;
        }
        unless ( defined( $self->schema_version )
            && $self->schema_version > 0 )
        {
            $self->error_code(9);
            return 0;
        }

        $self->_upgrade_schema_to( $params{upgrade_metadata_to} )
          if ( $self->schema_version < $params{upgrade_metadata_to} );

    }
    else {
        unless ( $self->_connect ) {
            return 0;    # $self->error_code is already set
        }
        $self->{schema_version} = 0;
    }

    local $self->_dbh->{PrintError} = 0;

    $self->_dbh->do("PRAGMA foreign_keys = ON");
    $self->_dbh->do("PRAGMA default_synchronous = OFF");

    if (   $params{upgrade_metadata_to}
        && $self->schema_version < $params{upgrade_metadata_to} )
    {
        unless ( $self->_upgrade_schema_to( $params{upgrade_metadata_to} ) ) {
            return 0;    # $self->error_code is already set
        }

    }

    return 1;            # Returns true
}

sub close {
    my $self = shift;
    $self->_disconnect;
    $self->error_code(0);
}

sub _connect {
    my $self = shift;

    my $dbh = DBI->connect( "dbi:SQLite:dbname=$self->_filename", "", "" );
    unless ( defined $dbh ) {
        $self->error_code(6);
        return 0;
    }

    $self->{_dbh} = $dbh;
    return 1;    # Returns true
}

sub _disconnect {
    my $self = shift;

    $self->_dbh->disconnect;
    $self->{_dbh} = undef;
    return 1;    # Returns true
}

sub exists {
    my $self = shift;
    ( -e $self->_filename ) ? 1 : 0;
}

sub _upgrade_schema_to {
    my $self       = shift;
    my $upgrade_to = shift;

    my %db_schema_versions = (
        1 => [
'create table diffs (diff integer primary key not null, date_begin datetime not null, date_end datetime not null, message text);',
'create table options (name text primary key not null, value text);',
'create table files (file_id integer primary key autoincrement not null, diff integer not null, path_id integer not null, localfile_id integer, retrieval_date datetime not null, owner text, "group" text, mode text, mdate datetime not null, type text not null, size integer not null, target text );',
'create table paths (path_id integer primary key autoincrement not null, path text not null);',
'create table localfiles (localfile_id integer primary key autoincrement not null, path text not null, size integer not null, key_id integer);',
'create table keys ( key_id integer primary key autoincrement not null, key blob not null);',
        ],
    );

    verbose_message("Metadata schema needs upgrade, do not interrupt...")
      if ( $self->_verbose );

    for ( my $i = $self->schema_version + 1 ; $i <= $upgrade_to ; $i++ ) {

        eval {
            local $self->_dbh->{RaiseError} = 1;
            local $self->_dbh->{PrintError} = 0;
            $self->_dbh->begin_work;
            foreach ( @{ $db_schema_versions{$i} } ) {
                $DB::single = 1;
                $self->_dbh->do($_);
            }
            $self->_dbh->do(
                "update options set value = $i where name = 'metadata_version';"
            );
        };
        if ($@) {
            $self->_dbh->rollback;
            $self->error_code(14);
            return 0;
        }
        else {
            $self->_dbh->commit;
            $self->{schema_version} = $i;

        }
    }

    verbose_message("Finished upgrade of metadata schema")
      if ( $self->_verbose );

    return 1;    # Returns true
}

sub set_message {
    my ( $self, $message ) = @_;

    $DB::single = 1;
    $self->_dbh->do(
        "update diffs set message = $message where diff = ${self->diff};")
      if ( $self->diff );

}

###############################
#
# Class:  Rdiffopke::Repository
#
###############################

package Rdiffopke::Repository;

sub new {
    my $class = shift;
    $DB::single = 1;
    my %params = @_;
    return unless ( defined $params{dir} );
    return bless {
        _dir                 => $params{dir},
        error_code           => 0,
        _verbose             => $params{verbose},
        _no_encryption       => $params{no_encryption},
        _upgrade_metadata_to => $params{upgrade_metadata_to},
    };

}

sub init {
    my $self = shift;

    if ( -e $self->_dir && !-d $self->_dir ) {
        $self->error(12);
        return 0;

    }
    else {
        verbose_message("Creating local reverse-diffs directory '$self->_dir'")
          if ( $self->_verbose );
        mkdir $self->_dir;
    }

    unless ( -d $self->_dir
        && -x $self->_dir
        && -w $self->_dir )
    {
        $self->error_code(2);
        return 0;
    }

    my $userkey = Rdiffopke::Userkey->new(
        dir     => $self->_dir,
        verbose => $self->_verbose
    );
    my $metadata = Rdiffopke::Metadata->new(
        dir     => $self->_dir,
        verbose => $self->_verbose
    );

#  if (! $userkey->exists && !$self->_no_encryption && </Users/alex/tmp/rdiffopke/*> ) {
    my $tmp = $self->_dir;
    if ( !$userkey->exists && !$self->_no_encryption && <$tmp/*> ) {
        $self->error_code(3);
        return 0;
    }

    if ( $self->_no_encryption && -e $userkey->exists ) {
        $self->error_code(4);
        return 0;
    }

    if (   $metadata->exists
        && !$userkey->exists
        && !$self->_no_encryption )
    {
        $self->error_code(5);
        return 0;
    }

    unless ( $self->_no_encryption ) {
        unless ( $userkey->init ) {
            $self->error_code( $userkey->error_code );
            return 0;
        }
    }

    $DB::single = 1;
    unless ( $metadata->init( upgrade_to => $self->{_upgrade_metadata_to} ) ) {
        $self->error_code( $metadata->error_code );
        return 0;
    }

    $self->{metadata} = $metadata;
    $self->{userkey}  = $userkey;

    return 1;    # Returns true;
}

sub close {
    my $self = shift;
    $self->metadata->close if ( defined $self->metadata );
}

sub schema_version {
    my $self = shift;
    return $self->metadata->schema_version;
}

sub set_message {
    my ( $self, $message ) = @_;
    $DB::single = 1;
    $self->metadata->set_message($message) if ( $self->metadata );
}

sub tell_which_files_needed {
    my $self            = shift;
    my $source_filelist = shift

      if (!defined $source_filelist
        || ref($source_filelist) ne 'Rdiffopke::Filelist' )
    {
        $self->error_code() return undef;
    }

    my $need_filelist = Rdiffopke::Filelist->new();

# TODO : Do file list compare with repository content and fill $need_filelist with items to be refreshed

    return $need_filelist;
}


###############################
#
# Class:  Rdiffopke::Filesource
#
###############################

package Rdiffopke::Filesource;

# Rdiffopke::Filesource->new gets an URL and return an initialized object of a relevant derived class, depending of URL parameter
sub new {
    my $class  = shift;
    my %params = @_;
    return unless ( defined $params{url} );

    #   case $url
    #match ^ftp://

    return Rdiffopke::Filesource::_Localdir->new( dir = $params{url},
        verbose => $params{verbose} );
    return bless {
        error_code => 0,
        _verbose   => $params{verbose},
    };

}

sub prepare {
    return 1;    # return true
}

sub get_file_list {
    return ();
}


###############################
#
# Class:  Rdiffopke::Filesource::_Localdir
#
###############################

package Rdiffopke::Filesource::_Localdir;

sub new {
    my $class  = shift;
    my %params = @_;
    return unless ( defined $params{dir} );

    return bless {
        error_code => 0,
        _verbose   => $params{verbose},
        _dir       => $params{dir},
    };
}

sub prepare {
    my $self = shift;
    return 1;    # return true
}

sub get_detailed_file_list {
    my $self = shift;

    my $filelist = $Rdiffopke::Filelist->new;

    # Fill filelist there

    return $filelist;
}


###############################
#
# Class:  Rdiffopke::Filelist
#
###############################

package Rdiffopke::Filelist;

sub new {
    return bless [];
}

sub add {
    my $self = shift;

}


###############################
#
# Class:  Rdiffopke::Userkey
#
###############################

package Rdiffopke::Userkey;

sub new {
    my $class  = shift;
    my %params = @_;
    return unless ( defined $params{dir} );
    return bless {
        error_code => 0,
        _verbose   => $params{verbose},
        _filename  => "$params{dir}/pubkey",
    };

}

sub exists {
    my $self = shift;
    ( -e $self->_filename ) ? 1 : 0;
}

